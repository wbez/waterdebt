# Generated by Django 3.2.5 on 2021-07-14 20:58
from django.db import migrations
from django.db import transaction
from debt.models import Property, Debt, Case
from water.settings import BASE_DIR
import agate, agateexcel
import re
from utils.migration_utils import partition_address

### START CONFIG ###
data_dir = str(BASE_DIR) + '/data/'
metered_unmetered_path = data_dir + 'Metered.NonMeteredproperties.xlsx'
debt_data_path = data_dir + 'FOIA Response - Utility Debt Law Firms WBEZ MIZ.xlsx'
admin_data_path = data_dir + 'Administrative hearings data.xlsx'
# not sure about this dataset ... no addresses
delinquent_data_path = data_dir + 'Delinquent Accounts 2010 to Present WBEZ MIZ.xlsx'
street_suffixes = ['AVE','BLVD','CT','DR','PL','RD','ST']
### END CONFIG ###


def load_data(apps,schema_editor):
    """
    load each object to db separately
    then look them up for fk refs
    """
    load_property()
    load_debt()
    load_case()



def find_numerical_address(split_address):
    """
    coerce first split element to int
    or else give up and return None
    """
    try:
        return split_address[0] if int(split_address[0]) else None
    except:
        return None


def find_street_name(split_address, numerical, directional, suffix, unit, unit_before):
    """
    the hardest part.
    start from the earliest possible index and bump it depending on 
    how many things precede it
    """
    street_name_starting_position = 0
    street_name_ending_position = -1 

    if numerical:
        street_name_starting_position += 1
    if unit_before:
        street_name_starting_position += 1
    if directional:
        street_name_starting_position += 1

    if suffix: # easy way to see where the street name ends
        suffix_count = split_address.count(suffix) # don't get fooled by DR and ST when they're part of the street name e.g. DR MLK JR DR
        if suffix_count > 1:
            street_name_ending_position = split_address.index(suffix,split_address.index(suffix))
        street_name_ending_position = split_address.index(suffix)
    elif unit and not unit_before: # if we don't have a suffix, check for a unit after the street name
        street_name_ending_position = split_address.index('UNIT')
    return ' '.join(split_address[street_name_starting_position:street_name_ending_position])
 

def find_street_suffix(split_address):
    """ 
    see if hardcoded suffixes match any address parts
    and return them
    """
    # assumes all caps
    for suffix in street_suffixes:
        if suffix in split_address:
            return suffix    
   

def find_unit_no(split_address,zipcode):
    """
    if there's a "unit"
    use the index to return that substring
    plus everything up until the last element [-1] (zipcode)

    ... alternatively, return the second numerical address part ...
    
    and specify if the unit number is before the street name (True)
    """
    # if a zipcode is present, exclude it from the unit segment
    unit_end_index = -1 if zipcode else None
    try:
        # assumes all caps
        if 'UNIT' in split_address:
            unit_start_index = split_address.index('UNIT')
            return ' '.join(split_address[unit_start_index:unit_end_index]), False
        # sometimes the unit number follows numerical address
        elif int(split_address[1]) or int(split_address) == 0: # or len < 5 and not in suffixes
            return split_address[1], True
            #TODO resolve situations where unit has alpha characters, e.g. 221 B Baker St
    except: # need to catch exception when 2nd check fails validation
        return None, None

def find_zipcode(split_address):
    """
    takes last item from split address
    and checks if its zip or zip+4
    and if it checks out as int (minus the - sign in zip+4)
    """
    try:
        return split_address[-1] if len(split_address[-1]) in (5,10) and int(split_address[-1].replace('-','')) else None
    except:
        return None

def load_property():
    """
    load metered/unmetered data
    from water dept
    """
    # read excel sheets into agate tables
    metered = agate.Table.from_xlsx(metered_unmetered_path,sheet='Metered properties')
    unmetered = agate.Table.from_xlsx(metered_unmetered_path,sheet='NonMetered')
    # metered properties are listed in their own sheet
    for meter in metered:
        meter_dict = row_to_dict(meter,metered.column_names)
        create_prop(full_address=meter_dict['Address'],metered=True) 

    # unmetered properties listed in the other sheet, different columns
    for unmeter in unmetered:
        unmeter_dict = row_to_dict(unmeter,unmetered.column_names)
        create_prop(full_address=unmeter_dict['address nonMetered'],metered=False)


def create_prop(full_address,metered):
    """
    create a property record from a full address
    """
    partitioned_address = partition_address(full_address)
    # the bare minimum needed to create a property
    if partitioned_address['numerical'] and partitioned_address['street_name']:
        try:
            with transaction.atomic(): # keep looping after IntegrityError (unique) 
                prop = Property.objects.create(
                        full_address=full_address,
                        numeric_address = partitioned_address['numerical'],
                        street_dir = partitioned_address['directional'],
                        street_name = partitioned_address['street_name'],
                        street_suffix = partitioned_address['street_suffix'],
                        unit = partitioned_address['unit'],
                        zipcode = partitioned_address['zipcode'],
                        metered = metered)
                prop.save()
                print(prop.__dict__)
        except Exception as e:
            print(e)


def load_debt():
    """
    load debt data
    from finance dept
    """
    # read excel sheets into agate tables
    debt_data_2015 = agate.Table.from_xlsx(debt_data_path,sheet='2010-2015 Detail')
    debt_data_2020 = agate.Table.from_xlsx(debt_data_path,sheet='2016-2021 Detail')
    
    # combine rows for concise code
    print('combining debt sheets')
    debt_data = debt_data_2015.rows.values() + debt_data_2020.rows.values()

    # debt 2010-2015
    for dd in debt_data:
        dd_dict = row_to_dict(dd, debt_data_2015.column_names)
        # the hard part here is water debt and finance dept addresses are prob structured differently
        partitioned_address = partition_address(dd_dict['PREMADDRESS'])
        print(partitioned_address)
        with transaction.atomic():
            try: 
                debt = Debt.objects.create(
                        full_address = dd_dict['PREMADDRESS'],
                        numeric_address = partitioned_address['numerical'],
                        street_dir = partitioned_address['directional'],
                        street_name = partitioned_address['street_name'],
                        street_suffix = partitioned_address['street_suffix'],
                        unit = partitioned_address['unit'],
                        zipcode = partitioned_address['zipcode'],
                        bad_debt_no = dd_dict['BDBTNUM'], 
                        debt_collector = dd_dict['ACGY_NAME'],
                        debt_date = dd_dict['ASSIGNED_DATE'],
                        debt_amt = dd_dict['BD_AMT'],
                        # penalty???
                        payment = dd_dict['PYMT_AMT'],
                        payment_date = dd_dict['PYMT_CREATE_DATE'],
                        payment_water = dd_dict['PYMTS_WTR'],
                        payment_sewer = dd_dict['PYMTS_SWR'],
                        payment_other = dd_dict['PYMTS_OTH'],
                        payment_water_tax = dd_dict['PYMTS_WTRTAX'],
                        payment_sewer_tax = dd_dict['PYMTS_SWRTAX'],
                        payment_refuse = dd_dict['PYMTS_REFUSE'],
                        payment_water_penalty = dd_dict['PYMTS_WTRPEN'],
                        payment_sewer_penalty = dd_dict['PYMTS_SWRPEN'],
                        payment_refuse_penalty = dd_dict['PYMTS_REFUSEPEN'],
                        fee_water = dd_dict['FEE_WTR'],
                        fee_sewer = dd_dict['FEE_SWR'],
                        fee_other = dd_dict['FEE_OTH'],
                        fee_water_tax = dd_dict['FEE_WTRTAX'],
                        fee_sewer_tax = dd_dict['FEE_SWRTAX'],
                        fee_refuse = dd_dict['FEE_REFUSE'],
                        fee_water_penalty = dd_dict['FEE_WTRPEN'],
                        fee_sewer_penalty = dd_dict['FEE_SWRPEN'],
                        fee_refuse_penalty = dd_dict['FEE_REFUSEPEN']
                        # balance???
                        # we don't have status because delinquent acct file doesn't have full addresses
                        # no_occurrences?
                        )
                debt.save()
                print(debt.__dict__)
            except Exception as e:
                print(e)
                import ipdb; ipdb.set_trace()

def load_case():
    """
    load case data
    from admin law
    """
    # read excel sheet into agate table
    admin_data = agate.Table.from_xlsx(admin_data_path,sheet='Hearing Info')

    # load cases
    for admin_case in admin_data:
        try:
            case_dict = row_to_dict(admin_case,admin_data.column_names)
            case = Case.objects.create(
                    nov = case_dict['Nov #'],
                    docket_no = case_dict['Docket Number'],
                    nov_issued_date = case_dict['NOV Issued Date'],
                    hearing_date = case_dict['Hearing Date'],
                    street_dir = case_dict['NOV Street Direction Prefix Code'],
                    street_name = case_dict['NOV Street Name'],
                    zip_code = case_dict['NOV Zip Code'],
                    violation = case_dict['MCV Description w/ Disposition'],
                    disposition = case_dict['Disposition Description'],
                    admin_cost = case_dict['Admin Costs'],
                    sanction_cost = case_dict['Sanction Dollars'],
                    fine = case_dict['Imposed Fine Detailed'],
                    # respondent = case_dict # TODO: read in respondent sheet
                    )
            case.save()
            print(case.__dict__)
        except Exception as e:
            print(e)
            import ipdb; ipdb.set_trace()
        

def row_to_dict(row, header):
    """
    build a dict from agate header + rows
    """
    return {header[i] : row[i] for i in range(len(header))}


class Migration(migrations.Migration):

    dependencies = [
        ('debt', '0001_initial'),
    ]

    operations = [
            migrations.RunPython(load_data)
    ]
